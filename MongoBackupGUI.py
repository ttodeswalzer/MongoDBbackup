#!/usr/bin/env python3
"""
MongoBackupGUI.py - MongoDB Yedekleme Mod√ºl√º
Versiyon: 2.0
G√ºvenlik: ≈ûifreli config, tarih bazlƒ± yedekleme, mod√ºler yapƒ±
"""

import json
import os
import sys
import threading
from datetime import datetime
from tkinter import filedialog, messagebox, ttk
import tkinter as tk
from sshtunnel import SSHTunnelForwarder
import base64
from cryptography.fernet import Fernet
from dotenv import load_dotenv

# .env dosyasƒ±nƒ± y√ºkle
load_dotenv()

try:
    import pymongo
    from bson import ObjectId
    from bson.binary import Binary
except ImportError:
    pymongo = None
    ObjectId = None
    Binary = None


def get_base_path():
    """Get the base path for file operations (works for both .py and .exe)"""
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))


class ConfigManager:
    """G√ºvenli config y√∂netimi - ≈üifreli depolama"""
    
    def __init__(self, config_file):
        self.config_file = config_file
        self.key_file = config_file.replace('.json', '.key')
        self.cipher = None
        self._init_encryption()
    
    def _init_encryption(self):
        """≈ûifreleme anahtarƒ±nƒ± ba≈ülat"""
        if os.path.exists(self.key_file):
            with open(self.key_file, 'rb') as f:
                key = f.read()
        else:
            key = Fernet.generate_key()
            with open(self.key_file, 'wb') as f:
                f.write(key)
            # Key dosyasƒ±nƒ± gizle (Windows)
            if sys.platform == 'win32':
                try:
                    import subprocess
                    subprocess.run(['attrib', '+H', self.key_file], shell=True)
                except:
                    pass
        
        self.cipher = Fernet(key)
    
    def save_config(self, config):
        """Config'i ≈üifreli olarak kaydet"""
        try:
            # Hassas bilgileri ≈üifrele
            encrypted_config = config.copy()
            if 'ssh_password' in encrypted_config and encrypted_config['ssh_password']:
                encrypted_config['ssh_password'] = self.cipher.encrypt(
                    encrypted_config['ssh_password'].encode()
                ).decode()
                encrypted_config['_ssh_encrypted'] = True
            
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(encrypted_config, f, indent=2)
            return True
        except Exception as e:
            print(f"Config kaydetme hatasƒ±: {e}")
            return False
    
    def load_config(self):
        """Config'i ≈üifreli olarak y√ºkle"""
        # √áevre deƒüi≈ükenlerinden varsayƒ±lan deƒüerleri al
        backup_dir_name = os.getenv('BACKUP_DIR_NAME', 'damise_backups')
        ssh_host = os.getenv('SSH_LOCAL_BIND_ADDRESS', 'localhost')
        ssh_port = int(os.getenv('SSH_DEFAULT_PORT', '22'))
        mongo_host = os.getenv('MONGODB_DEFAULT_HOST', 'localhost')
        mongo_port = int(os.getenv('MONGODB_DEFAULT_PORT', '27017'))
        
        default_config = {
            "ssh_host": ssh_host,
            "ssh_port": ssh_port,
            "ssh_username": "",
            "ssh_password": "",
            "mongo_host": mongo_host,
            "mongo_port": mongo_port,
            "saved_databases": [],
            "backup_dir": os.path.join(os.path.expanduser("~"), backup_dir_name),
            "_ssh_encrypted": False
        }
        
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                
                # ≈ûifreli ≈üifreyi √ß√∂z
                if config.get('_ssh_encrypted') and config.get('ssh_password'):
                    try:
                        decrypted_pass = self.cipher.decrypt(
                            config['ssh_password'].encode()
                        ).decode()
                        config['ssh_password'] = decrypted_pass
                    except Exception:
                        config['ssh_password'] = ""
                        config['_ssh_encrypted'] = False
                
                # Eski format uyumluluƒüu
                if isinstance(config.get("saved_databases"), str):
                    config["saved_databases"] = [config["saved_databases"]]
                
                default_config.update(config)
                return default_config
            else:
                self.save_config(default_config)
                return default_config
        except Exception as e:
            print(f"Config y√ºkleme hatasƒ±: {e}")
            return default_config


class SSHPresetManager:
    """SSH baƒülantƒ± √∂nayarlarƒ±nƒ± y√∂neten sƒ±nƒ±f"""
    
    def __init__(self, config_manager, logger=None):
        self.config_manager = config_manager
        self.logger = logger
        self.presets_key = "ssh_presets"
    
    def log(self, message):
        if self.logger:
            self.logger(message)
    
    def save_preset(self, name, ssh_host, ssh_port, ssh_username, mongo_host, mongo_port):
        """SSH preset kaydet (≈üifre hari√ß)"""
        try:
            config = self.config_manager.load_config()
            if self.presets_key not in config:
                config[self.presets_key] = {}
            
            preset_data = {
                "ssh_host": ssh_host,
                "ssh_port": ssh_port, 
                "ssh_username": ssh_username,
                "mongo_host": mongo_host,
                "mongo_port": mongo_port,
                "created_date": datetime.now().isoformat()
            }
            
            config[self.presets_key][name] = preset_data
            
            if self.config_manager.save_config(config):
                self.log(f"üíæ SSH preset '{name}' kaydedildi")
                return True
            else:
                self.log(f"‚ùå SSH preset '{name}' kaydedilemedi")
                return False
        except Exception as e:
            self.log(f"‚ùå Preset kaydetme hatasƒ±: {str(e)}")
            return False
    
    def load_presets(self):
        """T√ºm presetleri y√ºkle"""
        try:
            config = self.config_manager.load_config()
            return config.get(self.presets_key, {})
        except Exception as e:
            self.log(f"‚ùå Preset y√ºkleme hatasƒ±: {str(e)}")
            return {}
    
    def get_preset(self, name):
        """Belirli bir preset'i getir"""
        presets = self.load_presets()
        return presets.get(name, None)
    
    def delete_preset(self, name):
        """Preset sil"""
        try:
            config = self.config_manager.load_config()
            if self.presets_key in config and name in config[self.presets_key]:
                del config[self.presets_key][name]
                if self.config_manager.save_config(config):
                    self.log(f"üóëÔ∏è SSH preset '{name}' silindi")
                    return True
            return False
        except Exception as e:
            self.log(f"‚ùå Preset silme hatasƒ±: {str(e)}")
            return False


class BackupManager:
    """Yedekleme i≈ülemlerini y√∂neten sƒ±nƒ±f - Tarih bazlƒ± dosya yapƒ±sƒ±"""

    def __init__(self, mongo_uri, backup_dir, logger=None):
        self.mongo_uri = mongo_uri
        self.backup_dir = backup_dir
        self.logger = logger

    def log(self, message):
        """Log mesajƒ± g√∂nder"""
        if self.logger:
            self.logger(message)

    def _json_serializable(self, obj):
        """√ñzel t√ºrleri JSON serile≈ütirilebilir hale getirir"""
        if isinstance(obj, ObjectId):
            return str(obj)
        elif isinstance(obj, datetime):
            return obj.isoformat()
        elif isinstance(obj, Binary):
            return base64.b64encode(obj).decode('utf-8')
        elif isinstance(obj, bytes):
            return base64.b64encode(obj).decode('utf-8')
        raise TypeError(f"Type {type(obj)} is not JSON serializable")

    def _create_date_folder(self):
        """Bug√ºn√ºn tarihinde klas√∂r olu≈ütur"""
        today = datetime.now().strftime("%d.%m.%Y")
        date_folder = os.path.join(self.backup_dir, today)
        os.makedirs(date_folder, exist_ok=True)
        return date_folder

    def backup_collection(self, db_name, collection_name, output_file):
        """Tek bir koleksiyonu yedekle"""
        try:
            client = pymongo.MongoClient(self.mongo_uri, serverSelectionTimeoutMS=10000)
            db = client[db_name]
            collection = db[collection_name]

            self.log(f"‚è≥ {db_name}.{collection_name} koleksiyonu yedekleniyor...")

            with open(output_file, 'w', encoding='utf-8') as f:
                first = True
                f.write('[')
                for doc in collection.find(batch_size=1000):
                    if not first:
                        f.write(',')
                    json.dump(doc, f, default=self._json_serializable, ensure_ascii=False)
                    first = False
                f.write(']')

            self.log(f"‚úÖ {db_name}.{collection_name} koleksiyonu yedeklendi")
            client.close()
            return True

        except Exception as e:
            self.log(f"‚ùå {db_name}.{collection_name} yedeklenirken hata: {str(e)}")
            return False

    def backup_database(self, db_name):
        """T√ºm veritabanƒ±nƒ± tarih klas√∂r√ºne yedekle"""
        try:
            client = pymongo.MongoClient(self.mongo_uri, serverSelectionTimeoutMS=10000)
            db = client[db_name]

            # Tarih klas√∂r√º olu≈ütur
            date_folder = self._create_date_folder()
            timestamp = datetime.now().strftime("%H%M%S")
            
            collections = db.list_collection_names()
            success_count = 0

            if len(collections) == 1:
                # Tek koleksiyon varsa doƒürudan veritabanƒ± adƒ±yla kaydet
                collection_name = collections[0]
                output_file = os.path.join(date_folder, f"{db_name}.json")
                if self.backup_collection(db_name, collection_name, output_file):
                    success_count += 1
                    self.log(f"‚úÖ {db_name} veritabanƒ± tek dosya olarak yedeklendi: {output_file}")
            else:
                # Birden fazla koleksiyon varsa klas√∂r olu≈ütur
                db_folder = os.path.join(date_folder, f"{db_name}_{timestamp}")
                os.makedirs(db_folder, exist_ok=True)
                
                for collection_name in collections:
                    output_file = os.path.join(db_folder, f"{collection_name}.json")
                    if self.backup_collection(db_name, collection_name, output_file):
                        success_count += 1
                
                self.log(f"‚úÖ {db_name} veritabanƒ± klas√∂r olarak yedeklendi: {db_folder}")

            client.close()
            self.log(f"üìä {success_count}/{len(collections)} koleksiyon ba≈üarƒ±yla yedeklendi")

            return date_folder, success_count == len(collections)

        except Exception as e:
            self.log(f"‚ùå {db_name} veritabanƒ± yedeklenirken hata: {str(e)}")
            return None, False

    def backup_selected_collections(self, db_name, collections):
        """Se√ßili koleksiyonlarƒ± tarih klas√∂r√ºne yedekle"""
        try:
            date_folder = self._create_date_folder()
            timestamp = datetime.now().strftime("%H%M%S")
            
            success_count = 0

            if len(collections) == 1:
                # Tek koleksiyon
                collection_name = collections[0]
                output_file = os.path.join(date_folder, f"{db_name}_{collection_name}.json")
                if self.backup_collection(db_name, collection_name, output_file):
                    success_count += 1
            else:
                # Birden fazla koleksiyon
                output_dir = os.path.join(date_folder, f"{db_name}_selected_{timestamp}")
                os.makedirs(output_dir, exist_ok=True)
                
                for collection_name in collections:
                    output_file = os.path.join(output_dir, f"{collection_name}.json")
                    if self.backup_collection(db_name, collection_name, output_file):
                        success_count += 1

            self.log(f"‚úÖ {db_name} se√ßili yedekleme tamamlandƒ±: {date_folder}")
            self.log(f"üìä {success_count}/{len(collections)} koleksiyon ba≈üarƒ±yla yedeklendi")

            return date_folder, success_count == len(collections)

        except Exception as e:
            self.log(f"‚ùå {db_name} se√ßili koleksiyonlarƒ± yedeklenirken hata: {str(e)}")
            return None, False


class ConnectionManager:
    """Baƒülantƒ± y√∂netimini saƒülayan sƒ±nƒ±f"""

    def __init__(self, logger=None):
        self.ssh_tunnel = None
        self.mongo_uri = None
        self.is_connected = False
        self.available_dbs = []
        self.logger = logger

    def log(self, message):
        """Log mesajƒ± g√∂nder"""
        if self.logger:
            self.logger(message)

    def connect_ssh(self, ssh_host, ssh_port, username, password, mongo_host, mongo_port):
        """SSH baƒülantƒ±sƒ± kur"""
        try:
            # √áevre deƒüi≈ükenlerinden local bind address'i al
            local_bind_host = os.getenv('SSH_LOCAL_BIND_ADDRESS', 'localhost')
            
            self.log(f"SSH baƒülantƒ±sƒ± kuruluyor: {username}@{ssh_host}:{ssh_port}")

            self.ssh_tunnel = SSHTunnelForwarder(
                (ssh_host, ssh_port),
                ssh_username=username,
                ssh_password=password,
                remote_bind_address=(mongo_host, mongo_port),
                local_bind_address=(local_bind_host, 0)
            )
            self.ssh_tunnel.start()

            self.log(f"SSH t√ºneli ba≈üarƒ±yla a√ßƒ±ldƒ± ({local_bind_host}:{self.ssh_tunnel.local_bind_port})")
            return True, f"{local_bind_host}:{self.ssh_tunnel.local_bind_port}"

        except Exception as e:
            self.log(f"SSH baƒülantƒ± hatasƒ±: {str(e)}")
            return False, str(e)

    def connect_mongo(self):
        """MongoDB baƒülantƒ±sƒ±nƒ± test et ve veritabanlarƒ±nƒ± listele"""
        if not self.ssh_tunnel:
            return False, "SSH baƒülantƒ±sƒ± bulunamadƒ±"

        try:
            # √áevre deƒüi≈ükenlerinden deƒüerleri al
            local_bind_host = os.getenv('SSH_LOCAL_BIND_ADDRESS', 'localhost')
            connection_timeout = int(os.getenv('MONGODB_CONNECTION_TIMEOUT', '5000'))
            
            self.mongo_uri = f"mongodb://{local_bind_host}:{self.ssh_tunnel.local_bind_port}/"
            client = pymongo.MongoClient(self.mongo_uri, serverSelectionTimeoutMS=connection_timeout)
            client.admin.command('ping')

            self.available_dbs = client.list_database_names()
            self.is_connected = True

            self.log(f"‚úÖ T√ºm veritabanlarƒ±: {', '.join(self.available_dbs)}")
            self.log(f"üìä Toplam {len(self.available_dbs)} veritabanƒ± bulundu")
            client.close()

            return True, self.available_dbs

        except Exception as e:
            self.log(f"‚ùå MongoDB baƒülantƒ± hatasƒ±: {str(e)}")
            return False, str(e)

    def get_collections(self, db_name):
        """Veritabanƒ±ndaki koleksiyonlarƒ± al"""
        if not self.is_connected:
            return []

        try:
            # √áevre deƒüi≈ükeninden timeout deƒüerini al
            connection_timeout = int(os.getenv('MONGODB_CONNECTION_TIMEOUT', '10000'))
            
            client = pymongo.MongoClient(self.mongo_uri, serverSelectionTimeoutMS=connection_timeout)
            db = client[db_name]
            collections = db.list_collection_names()
            client.close()
            return collections
        except Exception as e:
            self.log(f"‚ùå Koleksiyonlar alƒ±nƒ±rken hata: {str(e)}")
            return []

    def disconnect(self):
        """T√ºm baƒülantƒ±larƒ± kes"""
        try:
            if self.ssh_tunnel:
                self.ssh_tunnel.stop()
                self.log("SSH baƒülantƒ±sƒ± kapatƒ±ldƒ±")

            self.is_connected = False
            self.available_dbs = []
            self.mongo_uri = None

        except Exception as e:
            self.log(f"Baƒülantƒ± kapatma hatasƒ±: {str(e)}")


class DatabaseSaveManager:
    """Veritabanƒ± kaydetme ve y√ºkleme i≈ülemleri"""
    
    def __init__(self, config_manager, logger=None):
        self.config_manager = config_manager
        self.logger = logger
    
    def log(self, message):
        if self.logger:
            self.logger(message)
    
    def save_databases(self, databases, ssh_info):
        """Se√ßili veritabanlarƒ±nƒ± config'e kaydet"""
        try:
            config = self.config_manager.load_config()
            config['saved_databases'] = databases
            config.update(ssh_info)  # SSH bilgilerini de kaydet
            
            if self.config_manager.save_config(config):
                self.log(f"üíæ {len(databases)} veritabanƒ± g√ºvenli olarak kaydedildi: {', '.join(databases)}")
                return True
            else:
                self.log("‚ùå Veritabanlarƒ± kaydedilemedi")
                return False
        except Exception as e:
            self.log(f"‚ùå Kaydetme hatasƒ±: {str(e)}")
            return False
    
    def load_saved_databases(self):
        """Kaydedilmi≈ü veritabanlarƒ±nƒ± y√ºkle"""
        try:
            config = self.config_manager.load_config()
            return config.get('saved_databases', [])
        except Exception as e:
            self.log(f"‚ùå Y√ºkleme hatasƒ±: {str(e)}")
            return []


class MongoBackupGUI:
    def __init__(self, parent=None, auth_status=False, user_data=None, on_close_callback=None):
        if parent is None:
            raise RuntimeError("Bu mod√ºl baƒüƒ±msƒ±z olarak √ßalƒ±≈ütƒ±rƒ±lamaz. DamiseAuthGUI tarafƒ±ndan √ßaƒürƒ±lmalƒ±dƒ±r.")
        if not auth_status:
            messagebox.showerror("Yetkisiz Eri≈üim", "MongoDB Yedekleme Aracƒ±'nƒ± a√ßmak i√ßin admin giri≈üi yapmalƒ±sƒ±nƒ±z!")
            raise RuntimeError("Admin yetkisi olmadan MongoBackupGUI ba≈ülatƒ±lamaz.")

        # √áevre deƒüi≈ükenlerinden deƒüerleri al
        backup_app_title = os.getenv('BACKUP_APP_TITLE', 'Damise MongoDB Yedekleme Aracƒ±')
        app_version = os.getenv('APP_VERSION', '2.0')
        backup_window_width = int(os.getenv('BACKUP_WINDOW_WIDTH', '1000'))
        backup_window_height = int(os.getenv('BACKUP_WINDOW_HEIGHT', '900'))
        
        self.root = tk.Toplevel(parent)
        self.root.title(f"{backup_app_title} v{app_version} - G√ºvenli Tarih Bazlƒ± Sistem")
        self.root.geometry(f"{backup_window_width}x{backup_window_height}")
        self.root.resizable(True, True)
        self.on_close_callback = on_close_callback
        self.user_data = user_data

        # Config y√∂neticisi
        config_file_name = os.getenv('CONFIG_FILE_NAME', 'damise_config.json')
        config_file = os.path.join(get_base_path(), config_file_name)
        self.config_manager = ConfigManager(config_file)
        self.config = self.config_manager.load_config()

        # Gerekli mod√ºl kontrol√º
        if pymongo is None:
            messagebox.showerror("Eksik Mod√ºl", 
                               "pymongo mod√ºl√º bulunamadƒ±!\n\nL√ºtfen ≈üu komutu √ßalƒ±≈ütƒ±rƒ±n:\npip install pymongo sshtunnel cryptography python-dotenv\n\nPython 3.8+ gereklidir.")
            self.root.destroy()
            return

        # Managers
        self.connection_manager = ConnectionManager(logger=self.log)
        self.backup_manager = None
        self.db_save_manager = DatabaseSaveManager(self.config_manager, logger=self.log)
        self.ssh_preset_manager = SSHPresetManager(self.config_manager, logger=self.log)

        # GUI bile≈üenlerini olu≈ütur
        self.create_widgets()

        # Pencere kapatma olayƒ±
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

        self.log("üöÄ MongoDB Yedekleme Aracƒ± v2.0 ba≈ülatƒ±ldƒ±")
        self.log(f"üë§ Kullanƒ±cƒ±: {user_data.get('name', '')} {user_data.get('surname', '')}")
        self.log("üîí G√ºvenli ≈üifreli sistem aktif")

    def create_widgets(self):
        """GUI bile≈üenlerini olu≈üturur"""
        main_frame = ttk.Frame(self.root, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Header
        self.create_header(main_frame)

        # Connection Frame
        self.create_connection_frame(main_frame)

        # Database Selection Frame
        self.create_database_frame(main_frame)

        # Backup Frame
        self.create_backup_frame(main_frame)

        # Log Frame
        self.create_log_frame(main_frame)

    def create_header(self, parent):
        """Header b√∂l√ºm√ºn√º olu≈ütur"""
        header_frame = ttk.Frame(parent)
        header_frame.pack(fill=tk.X, pady=(0, 20))

        title_label = ttk.Label(header_frame, text="üìÇ MongoDB G√ºvenli Yedekleme Sistemi v2.0",
                               font=('Arial', 16, 'bold'))
        title_label.pack(side=tk.LEFT)

        # Kullanƒ±cƒ± bilgisi
        if self.user_data:
            user_label = ttk.Label(header_frame, 
                                  text=f"üë§ {self.user_data.get('name', '')} {self.user_data.get('surname', '')}",
                                  font=('Arial', 10), foreground="green")
            user_label.pack(side=tk.RIGHT)

    def create_connection_frame(self, parent):
        """Baƒülantƒ± ayarlarƒ± frame'ini olu≈ütur"""
        conn_frame = ttk.LabelFrame(parent, text="üîí G√ºvenli Baƒülantƒ± Ayarlarƒ±", padding="15")
        conn_frame.pack(fill=tk.X, pady=(0, 15))

        # Preset y√∂netimi frame
        preset_frame = ttk.Frame(conn_frame)
        preset_frame.pack(fill=tk.X, pady=(0, 15))
        
        ttk.Label(preset_frame, text="üìã Baƒülantƒ± √ñnayarlarƒ±:", font=('Arial', 10, 'bold')).pack(anchor=tk.W)
        
        preset_control_frame = ttk.Frame(preset_frame)
        preset_control_frame.pack(fill=tk.X, pady=(5, 0))
        
        # Preset dropdown
        ttk.Label(preset_control_frame, text="Kayƒ±tlƒ± Baƒülantƒ±lar:").pack(side=tk.LEFT)
        
        self.preset_var = tk.StringVar()
        self.preset_combo = ttk.Combobox(preset_control_frame, textvariable=self.preset_var, 
                                        state="readonly", width=20)
        self.preset_combo.pack(side=tk.LEFT, padx=(10, 10))
        self.preset_combo.bind('<<ComboboxSelected>>', self.load_selected_preset)
        
        ttk.Button(preset_control_frame, text="üì• Y√ºkle", 
                  command=self.load_selected_preset).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(preset_control_frame, text="üóëÔ∏è Sil", 
                  command=self.delete_selected_preset).pack(side=tk.LEFT)
        
        # Yeni preset kaydetme
        save_preset_frame = ttk.Frame(preset_frame)
        save_preset_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Label(save_preset_frame, text="Yeni Kayƒ±t:").pack(side=tk.LEFT)
        
        self.preset_name_var = tk.StringVar()
        preset_entry = ttk.Entry(save_preset_frame, textvariable=self.preset_name_var, width=20)
        preset_entry.pack(side=tk.LEFT, padx=(10, 10))
        
        ttk.Button(save_preset_frame, text="üíæ Kaydet", 
                  command=self.save_current_preset).pack(side=tk.LEFT)

        # Ayƒ±rƒ±cƒ± √ßizgi
        ttk.Separator(conn_frame, orient='horizontal').pack(fill=tk.X, pady=(15, 15))

        # SSH ayarlarƒ±
        ssh_frame = ttk.Frame(conn_frame)
        ssh_frame.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(ssh_frame, text="SSH Sunucusu:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.ssh_host_var = tk.StringVar()  # BO≈û BA≈ûLAR
        ttk.Entry(ssh_frame, textvariable=self.ssh_host_var, width=25).grid(row=0, column=1, sticky=tk.W, padx=5)

        ttk.Label(ssh_frame, text="Port:").grid(row=0, column=2, sticky=tk.W, padx=(15, 5))
        self.ssh_port_var = tk.StringVar(value="22")  # SADECE VARSAYILAN PORT
        ttk.Entry(ssh_frame, textvariable=self.ssh_port_var, width=8).grid(row=0, column=3, sticky=tk.W, padx=5)

        ttk.Label(ssh_frame, text="Kullanƒ±cƒ±:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.ssh_user_var = tk.StringVar()  # BO≈û BA≈ûLAR
        ttk.Entry(ssh_frame, textvariable=self.ssh_user_var, width=25).grid(row=1, column=1, sticky=tk.W, padx=5)

        ttk.Label(ssh_frame, text="üîë ≈ûifre:").grid(row=1, column=2, sticky=tk.W, padx=(15, 5))
        self.ssh_pass_var = tk.StringVar()  # ≈ûƒ∞FRE HER ZAMAN BO≈û BA≈ûLAR
        password_entry = ttk.Entry(ssh_frame, textvariable=self.ssh_pass_var, show="*", width=15)
        password_entry.grid(row=1, column=3, sticky=tk.W, padx=5)
        
        # ≈ûifre i√ßin √∂zel not
        ttk.Label(ssh_frame, text="‚ö†Ô∏è G√ºvenlik: ≈ûifre her seferinde girilmeli", 
                 foreground="red", font=('Arial', 8)).grid(row=2, column=2, columnspan=2, sticky=tk.W, padx=(15, 0))

        # MongoDB ayarlarƒ±
        mongo_frame = ttk.Frame(conn_frame)
        mongo_frame.pack(fill=tk.X, pady=(10, 10))

        # √áevre deƒüi≈ükenlerinden varsayƒ±lan deƒüerleri al
        mongo_host = os.getenv('MONGODB_DEFAULT_HOST', 'localhost')
        mongo_port = os.getenv('MONGODB_DEFAULT_PORT', '27017')

        ttk.Label(mongo_frame, text="MongoDB Host:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.mongo_host_var = tk.StringVar(value=mongo_host)  # SADECE VARSAYILAN
        ttk.Entry(mongo_frame, textvariable=self.mongo_host_var, width=25).grid(row=0, column=1, sticky=tk.W, padx=5)

        ttk.Label(mongo_frame, text="Port:").grid(row=0, column=2, sticky=tk.W, padx=(15, 5))
        self.mongo_port_var = tk.StringVar(value=mongo_port)  # SADECE VARSAYILAN
        ttk.Entry(mongo_frame, textvariable=self.mongo_port_var, width=8).grid(row=0, column=3, sticky=tk.W, padx=5)

        # Baƒülantƒ± butonlarƒ± ve durum
        btn_frame = ttk.Frame(conn_frame)
        btn_frame.pack(fill=tk.X, pady=(10, 0))

        ttk.Button(btn_frame, text="üîå SSH Baƒülan", command=self.connect_ssh_thread).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(btn_frame, text="üîó MongoDB Baƒülan", command=self.connect_mongo_thread).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(btn_frame, text="‚úÇÔ∏è Baƒülantƒ±yƒ± Kes", command=self.disconnect).pack(side=tk.LEFT)

        self.status_var = tk.StringVar(value="üî¥ G√ºvenli baƒülantƒ± bekleniyor...")
        ttk.Label(btn_frame, textvariable=self.status_var, foreground="blue").pack(side=tk.RIGHT)
        
        # Widget'lar olu≈üturulduktan SONRA presetleri y√ºkle
        self.root.after(100, self.refresh_preset_list)

    def create_database_frame(self, parent):
        """Veritabanƒ± se√ßimi frame'ini olu≈ütur"""
        db_frame = ttk.LabelFrame(parent, text="üìä Veritabanƒ± Y√∂netimi", padding="15")
        db_frame.pack(fill=tk.X, pady=(0, 15))

        # Top frame with save button
        db_top_frame = ttk.Frame(db_frame)
        db_top_frame.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(db_top_frame, text="Mevcut Veritabanlarƒ±:").pack(side=tk.LEFT)
        
        # Kaydet butonu
        self.save_db_btn = ttk.Button(db_top_frame, text="üíæ Se√ßilileri Kaydet", 
                                      command=self.save_selected_databases, state=tk.DISABLED)
        self.save_db_btn.pack(side=tk.RIGHT)

        # Listbox frame
        listbox_frame = ttk.Frame(db_frame)
        listbox_frame.pack(fill=tk.X, pady=(0, 10))

        self.db_listbox = tk.Listbox(listbox_frame, selectmode=tk.MULTIPLE, height=6)
        self.db_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar_db = ttk.Scrollbar(listbox_frame, command=self.db_listbox.yview)
        scrollbar_db.pack(side=tk.RIGHT, fill=tk.Y)
        self.db_listbox.config(yscrollcommand=scrollbar_db.set)

        self.db_listbox.insert(tk.END, "MongoDB'ye g√ºvenli baƒülantƒ± kurun...")

        # Kaydedilen veritabanlarƒ± g√∂ster
        saved_frame = ttk.Frame(db_frame)
        saved_frame.pack(fill=tk.X)
        
        ttk.Label(saved_frame, text="üíæ Kaydedilen Veritabanlarƒ±:", font=('Arial', 9, 'bold')).pack(anchor=tk.W)
        
        self.saved_db_var = tk.StringVar()
        saved_databases = self.db_save_manager.load_saved_databases()
        if saved_databases:
            self.saved_db_var.set(f"üìÅ {', '.join(saved_databases)} (≈ûifreli)")
        else:
            self.saved_db_var.set("üìÅ Hen√ºz kaydedilmi≈ü veritabanƒ± yok")
        
        ttk.Label(saved_frame, textvariable=self.saved_db_var, foreground="green", 
                 font=('Arial', 9)).pack(anchor=tk.W, pady=(5, 0))

    def create_backup_frame(self, parent):
        """Yedekleme frame'ini olu≈ütur"""
        backup_frame = ttk.LabelFrame(parent, text="üìÇ Tarih Bazlƒ± Yedekleme ƒ∞≈ülemleri", padding="15")
        backup_frame.pack(fill=tk.X, pady=(0, 15))

        # Yedekleme dizini
        dir_frame = ttk.Frame(backup_frame)
        dir_frame.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(dir_frame, text="Ana Yedekleme Dizini:").pack(anchor=tk.W)

        dir_input_frame = ttk.Frame(dir_frame)
        dir_input_frame.pack(fill=tk.X, pady=(5, 0))

        self.backup_dir_var = tk.StringVar(value=self.config["backup_dir"])
        ttk.Entry(dir_input_frame, textvariable=self.backup_dir_var, state="readonly").pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        ttk.Button(dir_input_frame, text="üìÅ Deƒüi≈ütir", command=self.select_backup_dir).pack(side=tk.RIGHT)

        # Tarih bilgisi
        today = datetime.now().strftime("%d.%m.%Y")
        info_frame = ttk.Frame(dir_frame)
        info_frame.pack(fill=tk.X, pady=(5, 0))
        
        ttk.Label(info_frame, text=f"üìÖ Bug√ºnk√º yedeklemeler: {self.backup_dir_var.get()}/{today}/", 
                 foreground="blue", font=('Arial', 9)).pack(anchor=tk.W)

        # Yedekleme butonlarƒ±
        btn_frame = ttk.Frame(backup_frame)
        btn_frame.pack(fill=tk.X, pady=(15, 0))

        ttk.Button(btn_frame, text="üóÑÔ∏è Tam Yedekleme", command=self.full_backup_thread, 
                  style="Accent.TButton").pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(btn_frame, text="üìÇ Se√ßili Koleksiyonlar", command=self.selective_backup_thread).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(btn_frame, text="üìÅ Yedek Klas√∂r√ºn√º A√ß", command=self.open_backup_folder).pack(side=tk.RIGHT)

    def create_log_frame(self, parent):
        """Log frame'ini olu≈ütur"""
        log_frame = ttk.LabelFrame(parent, text="üìù ƒ∞≈ülem Kayƒ±tlarƒ±", padding="15")
        log_frame.pack(fill=tk.BOTH, expand=True)

        self.log_text = tk.Text(log_frame, height=15, wrap=tk.WORD, font=('Courier', 9))
        self.log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar_log = ttk.Scrollbar(log_frame, command=self.log_text.yview)
        scrollbar_log.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text.config(yscrollcommand=scrollbar_log.set)

        # Log butonlarƒ±
        log_btn_frame = ttk.Frame(log_frame)
        log_btn_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(log_btn_frame, text="üóëÔ∏è Temizle", command=self.clear_log).pack(side=tk.LEFT)
        ttk.Button(log_btn_frame, text="üíæ Kaydet", command=self.save_log).pack(side=tk.LEFT, padx=(10, 0))

    def log(self, message):
        """Log mesajƒ± ekler"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_text.see(tk.END)
        self.root.update_idletasks()

    def clear_log(self):
        """Log'u temizle"""
        self.log_text.delete(1.0, tk.END)
        self.log("üìù Log temizlendi")

    def save_log(self):
        """Log'u dosyaya kaydet"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            log_file = os.path.join(get_base_path(), f"mongo_backup_log_{timestamp}.txt")
            
            with open(log_file, 'w', encoding='utf-8') as f:
                f.write(self.log_text.get(1.0, tk.END))
            
            self.log(f"üíæ Log kaydedildi: {log_file}")
            messagebox.showinfo("Ba≈üarƒ±lƒ±", f"Log dosyasƒ± kaydedildi:\n{log_file}")
        except Exception as e:
            self.log(f"‚ùå Log kaydetme hatasƒ±: {str(e)}")

    def refresh_preset_list(self):
        """Preset listesini yenile"""
        try:
            presets = self.ssh_preset_manager.load_presets()
            preset_names = list(presets.keys())
            
            # Widget mevcut mu kontrol et
            if hasattr(self, 'preset_combo') and self.preset_combo.winfo_exists():
                self.preset_combo['values'] = preset_names
                if preset_names:
                    self.log(f"üìã {len(preset_names)} kayƒ±tlƒ± baƒülantƒ± y√ºklendi: {', '.join(preset_names)}")
                else:
                    self.log("üìã Hen√ºz kayƒ±tlƒ± baƒülantƒ± bulunamadƒ±")
        except Exception as e:
            self.log(f"‚ö†Ô∏è Preset listesi y√ºklenirken hata: {str(e)}")

    def save_current_preset(self):
        """Mevcut ayarlarƒ± preset olarak kaydet"""
        try:
            preset_name = self.preset_name_var.get().strip()
            if not preset_name:
                messagebox.showwarning("Uyarƒ±", "L√ºtfen baƒülantƒ± i√ßin bir isim girin!")
                return
            
            # Mevcut deƒüerleri kontrol et
            if not all([self.ssh_host_var.get(), self.ssh_user_var.get()]):
                messagebox.showwarning("Uyarƒ±", "SSH Host ve Kullanƒ±cƒ± alanlarƒ± dolu olmalƒ±!")
                return
            
            # Port deƒüerlerini kontrol et
            try:
                ssh_port = int(self.ssh_port_var.get())
                mongo_port = int(self.mongo_port_var.get())
            except ValueError:
                messagebox.showwarning("Uyarƒ±", "Port deƒüerleri sayƒ± olmalƒ±!")
                return
            
            # Aynƒ± isimde preset var mƒ± kontrol et
            existing_presets = self.ssh_preset_manager.load_presets()
            if preset_name in existing_presets:
                result = messagebox.askyesno("Onay", 
                    f"'{preset_name}' adƒ±nda kayƒ±t zaten var.\n\n√úzerine yazƒ±lsƒ±n mƒ±?")
                if not result:
                    return
            
            # Preset kaydet (≈üifre hari√ß)
            success = self.ssh_preset_manager.save_preset(
                preset_name,
                self.ssh_host_var.get(),
                ssh_port,
                self.ssh_user_var.get(),
                self.mongo_host_var.get(),
                mongo_port
            )
            
            if success:
                self.preset_name_var.set("")  # ƒ∞sim alanƒ±nƒ± temizle
                self.refresh_preset_list()  # Listeyi yenile
                self.preset_var.set(preset_name)  # Yeni kaydedileni se√ß
                messagebox.showinfo("Ba≈üarƒ±lƒ±", 
                    f"‚úÖ '{preset_name}' baƒülantƒ± ayarlarƒ± kaydedildi!\n\nüîë G√ºvenlik: ≈ûifre kaydedilmedi, her seferinde girilmeli.")
            else:
                messagebox.showerror("Hata", "Baƒülantƒ± ayarlarƒ± kaydedilemedi!")
                
        except Exception as e:
            self.log(f"‚ùå Preset kaydetme hatasƒ±: {str(e)}")
            messagebox.showerror("Hata", f"Preset kaydedilemedi: {str(e)}")

    def load_selected_preset(self, event=None):
        """Se√ßili preset'i y√ºkle"""
        preset_name = self.preset_var.get()
        if not preset_name:
            return
        
        preset_data = self.ssh_preset_manager.get_preset(preset_name)
        if not preset_data:
            messagebox.showerror("Hata", f"'{preset_name}' preset'i bulunamadƒ±!")
            return
        
        # Alanlarƒ± doldur (≈üifre hari√ß)
        mongo_host = os.getenv('MONGODB_DEFAULT_HOST', 'localhost')
        mongo_port = int(os.getenv('MONGODB_DEFAULT_PORT', '27017'))
        
        self.ssh_host_var.set(preset_data.get("ssh_host", ""))
        self.ssh_port_var.set(str(preset_data.get("ssh_port", 22)))
        self.ssh_user_var.set(preset_data.get("ssh_username", ""))
        self.mongo_host_var.set(preset_data.get("mongo_host", mongo_host))
        self.mongo_port_var.set(str(preset_data.get("mongo_port", mongo_port)))
        
        # ≈ûifre alanƒ±nƒ± temizle (g√ºvenlik)
        self.ssh_pass_var.set("")
        
        created_date = preset_data.get("created_date", "")
        if created_date:
            try:
                date_obj = datetime.fromisoformat(created_date)
                date_str = date_obj.strftime("%d.%m.%Y %H:%M")
            except:
                date_str = "Bilinmiyor"
        else:
            date_str = "Bilinmiyor"
        
        self.log(f"üì• '{preset_name}' baƒülantƒ± ayarlarƒ± y√ºklendi (Kayƒ±t: {date_str})")
        self.log("üîë G√ºvenlik: L√ºtfen SSH ≈üifresini girin")

    def delete_selected_preset(self):
        """Se√ßili preset'i sil"""
        preset_name = self.preset_var.get()
        if not preset_name:
            messagebox.showwarning("Uyarƒ±", "L√ºtfen silinecek baƒülantƒ±yƒ± se√ßin!")
            return
        
        result = messagebox.askyesno("Onay", 
            f"'{preset_name}' baƒülantƒ± ayarlarƒ± silinecek.\n\nEmin misiniz?")
        
        if result:
            if self.ssh_preset_manager.delete_preset(preset_name):
                self.preset_var.set("")  # Se√ßimi temizle
                self.refresh_preset_list()  # Listeyi yenile
                messagebox.showinfo("Ba≈üarƒ±lƒ±", f"‚úÖ '{preset_name}' baƒülantƒ± ayarlarƒ± silindi!")
            else:
                messagebox.showerror("Hata", "Baƒülantƒ± ayarlarƒ± silinemedi!")

    def select_backup_dir(self):
        """Yedekleme dizinini se√ß"""
        dir_path = filedialog.askdirectory(title="Ana Yedekleme Dizini Se√ß")
        if dir_path:
            self.config["backup_dir"] = dir_path
            self.backup_dir_var.set(dir_path)
            self.config_manager.save_config(self.config)
            self.log(f"üìÅ Ana yedekleme dizini g√ºncellendi: {dir_path}")
            
            # Tarih bilgisini g√ºncelle
            today = datetime.now().strftime("%d.%m.%Y")
            messagebox.showinfo("Dizin G√ºncellendi", f"Yedekleme dizini g√ºncellendi.\n\nBug√ºnk√º yedeklemeler ≈üu klas√∂re kaydedilecek:\n{dir_path}/{today}/")

    def open_backup_folder(self):
        """Yedek klas√∂r√ºn√º a√ß"""
        try:
            backup_dir = self.backup_dir_var.get()
            if os.path.exists(backup_dir):
                if sys.platform == 'win32':
                    os.startfile(backup_dir)
                elif sys.platform == 'darwin':
                    os.system(f'open "{backup_dir}"')
                else:
                    os.system(f'xdg-open "{backup_dir}"')
                self.log(f"üìÅ Yedek klas√∂r√º a√ßƒ±ldƒ±: {backup_dir}")
            else:
                messagebox.showerror("Hata", f"Yedek klas√∂r√º bulunamadƒ±:\n{backup_dir}")
        except Exception as e:
            self.log(f"‚ùå Klas√∂r a√ßma hatasƒ±: {str(e)}")

    def save_selected_databases(self):
        """Se√ßili veritabanlarƒ±nƒ± ≈üifreli olarak kaydet"""
        selected_dbs = self.get_selected_databases()
        if not selected_dbs:
            messagebox.showwarning("Uyarƒ±", "L√ºtfen kaydetmek istediƒüiniz veritabanlarƒ±nƒ± se√ßin!")
            return
        
        # SSH bilgilerini de kaydet
        ssh_info = {
            "ssh_host": self.ssh_host_var.get(),
            "ssh_port": int(self.ssh_port_var.get()),
            "ssh_username": self.ssh_user_var.get(),
            "ssh_password": self.ssh_pass_var.get(),
            "mongo_host": self.mongo_host_var.get(),
            "mongo_port": int(self.mongo_port_var.get())
        }
        
        if self.db_save_manager.save_databases(selected_dbs, ssh_info):
            self.saved_db_var.set(f"üìÅ {', '.join(selected_dbs)} (≈ûifreli)")
            messagebox.showinfo("G√ºvenli Kaydetme", f"‚úÖ {len(selected_dbs)} veritabanƒ± g√ºvenli olarak kaydedildi!\n\nKaydedilen veritabanlarƒ±:\n‚Ä¢ " + "\n‚Ä¢ ".join(selected_dbs) + "\n\nüîí SSH bilgileri ≈üifreli olarak saklandƒ±.\nüíæ Bir sonraki a√ßƒ±lƒ±≈üta otomatik y√ºklenecek.")
        else:
            messagebox.showerror("Hata", "Veritabanlarƒ± kaydedilemedi!")

    def connect_ssh_thread(self):
        """SSH baƒülantƒ±sƒ±nƒ± thread'de √ßalƒ±≈ütƒ±r"""
        def ssh_worker():
            self.connect_ssh()

        thread = threading.Thread(target=ssh_worker)
        thread.daemon = True
        thread.start()

    def connect_ssh(self):
        """SSH baƒülantƒ±sƒ± kur"""
        if not all([self.ssh_host_var.get(), self.ssh_user_var.get(), self.ssh_pass_var.get()]):
            messagebox.showerror("Hata", "SSH bilgileri eksik!")
            return

        self.status_var.set("üîÑ G√ºvenli SSH baƒülantƒ±sƒ± kuruluyor...")

        success, result = self.connection_manager.connect_ssh(
            self.ssh_host_var.get(),
            int(self.ssh_port_var.get()),
            self.ssh_user_var.get(),
            self.ssh_pass_var.get(),
            self.mongo_host_var.get(),
            int(self.mongo_port_var.get())
        )

        if success:
            self.status_var.set("üü° SSH baƒülƒ± - MongoDB bekleniyor")
        else:
            self.status_var.set("üî¥ SSH baƒülantƒ± hatasƒ±")
            messagebox.showerror("SSH Hatasƒ±", f"G√ºvenli baƒülantƒ± kurulamadƒ±:\n{result}")

    def connect_mongo_thread(self):
        """MongoDB baƒülantƒ±sƒ±nƒ± thread'de √ßalƒ±≈ütƒ±r"""
        def mongo_worker():
            self.connect_mongo()

        thread = threading.Thread(target=mongo_worker)
        thread.daemon = True
        thread.start()

    def connect_mongo(self):
        """MongoDB baƒülantƒ±sƒ±nƒ± test et"""
        if not self.connection_manager.ssh_tunnel:
            messagebox.showerror("Hata", "√ñnce SSH baƒülantƒ±sƒ± kurmalƒ±sƒ±nƒ±z!")
            return

        self.status_var.set("üîÑ MongoDB g√ºvenli baƒülantƒ±sƒ± test ediliyor...")

        success, result = self.connection_manager.connect_mongo()

        if success:
            self.status_var.set("üü¢ G√ºvenli baƒülantƒ± ba≈üarƒ±lƒ±")
            self.update_database_list(result)
            self.backup_manager = BackupManager(
                self.connection_manager.mongo_uri,
                self.backup_dir_var.get(),
                logger=self.log
            )
            self.save_db_btn.config(state=tk.NORMAL)
        else:
            self.status_var.set("üî¥ MongoDB baƒülantƒ± hatasƒ±")
            messagebox.showerror("Hata", f"MongoDB g√ºvenli baƒülantƒ± hatasƒ±:\n{result}")

    def update_database_list(self, databases):
        """Veritabanƒ± listesini g√ºncelle"""
        self.db_listbox.delete(0, tk.END)
        for db in databases:
            self.db_listbox.insert(tk.END, db)

        # Kaydedilmi≈ü veritabanlarƒ±nƒ± otomatik se√ß
        saved_databases = self.db_save_manager.load_saved_databases()
        for db in saved_databases:
            if db in databases:
                idx = databases.index(db)
                self.db_listbox.selection_set(idx)
        
        if saved_databases:
            self.log(f"üìã Kaydedilmi≈ü veritabanlarƒ± otomatik se√ßildi: {', '.join(saved_databases)}")

    def disconnect(self):
        """T√ºm baƒülantƒ±larƒ± kes"""
        self.connection_manager.disconnect()
        self.db_listbox.delete(0, tk.END)
        self.db_listbox.insert(tk.END, "MongoDB'ye g√ºvenli baƒülantƒ± kurun...")
        self.status_var.set("üî¥ G√ºvenli baƒülantƒ±lar kapatƒ±ldƒ±")
        self.backup_manager = None
        self.save_db_btn.config(state=tk.DISABLED)

    def get_selected_databases(self):
        """Se√ßili veritabanlarƒ±nƒ± d√∂nd√ºr"""
        selected_indices = self.db_listbox.curselection()
        selected_dbs = [self.db_listbox.get(i) for i in selected_indices]
        return selected_dbs

    def full_backup_thread(self):
        """Tam yedeklemeyi thread'de √ßalƒ±≈ütƒ±r"""
        def backup_worker():
            self.full_backup()

        thread = threading.Thread(target=backup_worker)
        thread.daemon = True
        thread.start()

    def full_backup(self):
        """Tam veritabanƒ± yedeklemesi - Tarih bazlƒ±"""
        if not self.connection_manager.is_connected or not self.backup_manager:
            messagebox.showerror("Hata", "√ñnce MongoDB'ye g√ºvenli baƒülantƒ± kurmalƒ±sƒ±nƒ±z!")
            return

        selected_dbs = self.get_selected_databases()
        if not selected_dbs:
            messagebox.showerror("Hata", "L√ºtfen yedeklenecek en az bir veritabanƒ± se√ßin!")
            return

        # SSH bilgilerini config'e kaydet
        ssh_info = {
            "ssh_host": self.ssh_host_var.get(),
            "ssh_port": int(self.ssh_port_var.get()),
            "ssh_username": self.ssh_user_var.get(),
            "ssh_password": self.ssh_pass_var.get(),
            "mongo_host": self.mongo_host_var.get(),
            "mongo_port": int(self.mongo_port_var.get())
        }
        self.config.update(ssh_info)
        self.config_manager.save_config(self.config)

        backup_dir = self.backup_dir_var.get()
        if not os.path.exists(backup_dir):
            os.makedirs(backup_dir)

        self.backup_manager.backup_dir = backup_dir

        success_count = 0
        today = datetime.now().strftime("%d.%m.%Y")
        
        self.log(f"üöÄ Tam yedekleme ba≈ülatƒ±ldƒ± - Hedef: {backup_dir}/{today}/")
        
        for db_name in selected_dbs:
            # √áevre deƒüi≈ükeninden local bind host'u al
            local_bind_host = os.getenv('SSH_LOCAL_BIND_ADDRESS', 'localhost')
            self.backup_manager.mongo_uri = f"mongodb://{local_bind_host}:{self.connection_manager.ssh_tunnel.local_bind_port}/{db_name}"
            output_dir, success = self.backup_manager.backup_database(db_name)
            if success:
                success_count += 1

        if success_count == len(selected_dbs):
            messagebox.showinfo("Yedekleme Ba≈üarƒ±lƒ±", 
                              f"‚úÖ T√ºm veritabanlarƒ± ba≈üarƒ±yla yedeklendi!\n\nüìÅ Konum: {backup_dir}/{today}/\nüìä {success_count}/{len(selected_dbs)} veritabanƒ±\nüîí G√ºvenli tarih bazlƒ± sistem\n\nYedeklenen veritabanlarƒ±:\n‚Ä¢ " + "\n‚Ä¢ ".join(selected_dbs))
        else:
            messagebox.showwarning("Kƒ±smi Yedekleme", 
                                 f"‚ö†Ô∏è Kƒ±smi yedekleme tamamlandƒ±!\n\nüìÅ Konum: {backup_dir}/{today}/\nüìä {success_count}/{len(selected_dbs)} veritabanƒ± ba≈üarƒ±lƒ±\n\nL√ºtfen log kayƒ±tlarƒ±nƒ± kontrol edin.")

    def selective_backup_thread(self):
        """Se√ßili koleksiyon yedeklemesini thread'de ba≈ülat"""
        def backup_worker():
            self.selective_backup()

        thread = threading.Thread(target=backup_worker)
        thread.daemon = True
        thread.start()

    def selective_backup(self):
        """Se√ßili koleksiyonlarƒ± yedekle"""
        if not self.connection_manager.is_connected:
            messagebox.showerror("Hata", "√ñnce MongoDB'ye g√ºvenli baƒülantƒ± kurmalƒ±sƒ±nƒ±z!")
            return

        selected_dbs = self.get_selected_databases()
        if not selected_dbs:
            messagebox.showerror("Hata", "L√ºtfen en az bir veritabanƒ± se√ßin!")
            return

        for db_name in selected_dbs:
            collections = self.connection_manager.get_collections(db_name)
            if not collections:
                self.log(f"‚ùå {db_name} veritabanƒ±nda koleksiyon bulunamadƒ±")
                continue

            self.show_collection_selector(db_name, collections)

    def show_collection_selector(self, db_name, collections):
        """Koleksiyon se√ßici penceresi g√∂ster"""
        select_win = tk.Toplevel(self.root)
        select_win.title(f"üìÇ {db_name} - Koleksiyon Se√ßimi")
        select_win.geometry("520x650")
        select_win.resizable(True, True)

        # Ana frame
        main_frame = ttk.Frame(select_win, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Ba≈ülƒ±k
        title_label = ttk.Label(main_frame, text=f"üìÇ {db_name} Veritabanƒ±",
                                font=('Arial', 14, 'bold'))
        title_label.pack(pady=(0, 10))

        info_label = ttk.Label(main_frame, text="Yedeklenecek koleksiyonlarƒ± se√ßin:", 
                              font=('Arial', 10))
        info_label.pack(pady=(0, 10))

        # Tarih bilgisi
        today = datetime.now().strftime("%d.%m.%Y")
        date_label = ttk.Label(main_frame, text=f"üìÖ Hedef klas√∂r: damise_backups/{today}/", 
                              foreground="blue", font=('Arial', 9))
        date_label.pack(pady=(0, 15))

        # Listbox frame
        listbox_frame = ttk.Frame(main_frame)
        listbox_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))

        listbox = tk.Listbox(listbox_frame, selectmode=tk.MULTIPLE)
        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(listbox_frame, command=listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        listbox.config(yscrollcommand=scrollbar.set)

        # Koleksiyonlarƒ± listele
        for col in collections:
            listbox.insert(tk.END, col)

        # Se√ßim butonlarƒ±
        selection_frame = ttk.Frame(main_frame)
        selection_frame.pack(fill=tk.X, pady=(0, 15))

        def select_all():
            listbox.select_set(0, tk.END)

        def deselect_all():
            listbox.selection_clear(0, tk.END)

        ttk.Button(selection_frame, text="‚úÖ T√ºm√ºn√º Se√ß", command=select_all).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(selection_frame, text="‚ùå Se√ßimi Temizle", command=deselect_all).pack(side=tk.LEFT)

        # Info frame
        info_frame = ttk.Frame(main_frame)
        info_frame.pack(fill=tk.X, pady=(0, 15))

        count_label = ttk.Label(info_frame, text=f"üìä Toplam {len(collections)} koleksiyon mevcut")
        count_label.pack()

        # Ana butonlar
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X)

        def backup_selected():
            selected_cols = [listbox.get(i) for i in listbox.curselection()]
            if not selected_cols:
                messagebox.showerror("Hata", "En az bir koleksiyon se√ßmelisiniz!")
                return

            backup_dir = self.backup_dir_var.get()
            if not backup_dir or not os.path.exists(backup_dir):
                messagebox.showerror("Hata", "Ge√ßerli bir yedekleme dizini belirtmelisiniz!")
                return

            select_win.destroy()
            self.backup_selected_collections(db_name, selected_cols)

        def cancel_backup():
            select_win.destroy()

        ttk.Button(button_frame, text="üíæ Yedeklemeyi Ba≈ülat", command=backup_selected, 
                  style="Accent.TButton").pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(button_frame, text="‚ùå ƒ∞ptal", command=cancel_backup).pack(side=tk.LEFT)

        # Pencereyi ortalama ve modal yap
        select_win.transient(self.root)
        select_win.grab_set()
        select_win.geometry("+%d+%d" % (
            self.root.winfo_rootx() + 100,
            self.root.winfo_rooty() + 100
        ))

    def backup_selected_collections(self, db_name, collections):
        """Se√ßili koleksiyonlarƒ± yedekle"""
        if not self.backup_manager:
            return

        # √áevre deƒüi≈ükeninden local bind host'u al
        local_bind_host = os.getenv('SSH_LOCAL_BIND_ADDRESS', 'localhost')
        self.backup_manager.mongo_uri = f"mongodb://{local_bind_host}:{self.connection_manager.ssh_tunnel.local_bind_port}/{db_name}"
        self.backup_manager.backup_dir = self.backup_dir_var.get()

        today = datetime.now().strftime("%d.%m.%Y")
        self.log(f"üöÄ Se√ßili koleksiyon yedeklemesi ba≈ülatƒ±ldƒ± - {db_name}")
        self.log(f"üìÇ Hedef: {self.backup_dir_var.get()}/{today}/")

        output_dir, success = self.backup_manager.backup_selected_collections(db_name, collections)

        if success:
            messagebox.showinfo("Yedekleme Ba≈üarƒ±lƒ±", 
                              f"‚úÖ Se√ßili koleksiyonlar ba≈üarƒ±yla yedeklendi!\n\nüìÅ Konum: {output_dir}\nüìä {len(collections)} koleksiyon\nüîí G√ºvenli tarih bazlƒ± sistem\n\nYedeklenen koleksiyonlar:\n‚Ä¢ " + "\n‚Ä¢ ".join(collections))
        else:
            messagebox.showwarning("Kƒ±smi Yedekleme", 
                                 f"‚ö†Ô∏è Bazƒ± koleksiyonlar yedeklenemedi!\n\nüìÅ Konum: {output_dir}\n\nL√ºtfen log kayƒ±tlarƒ±nƒ± kontrol edin.")

    def on_closing(self):
        """Pencere kapatƒ±lƒ±rken g√ºvenli temizleme"""
        if messagebox.askokcancel("Mod√ºl Kapatma", "MongoDB Yedekleme mod√ºl√ºn√º kapatmak istiyor musunuz?\n\nT√ºm baƒülantƒ±lar g√ºvenli olarak kesilecektir."):
            self.log("üîí MongoDB mod√ºl√º g√ºvenli olarak kapatƒ±lƒ±yor...")
            
            # Baƒülantƒ±larƒ± kapat
            self.connection_manager.disconnect()
            self.log("‚úÖ T√ºm baƒülantƒ±lar g√ºvenli olarak kesildi")

            # Callback'i √ßaƒüƒ±r
            if self.on_close_callback:
                self.on_close_callback()

            self.root.destroy()


if __name__ == "__main__":
    messagebox.showerror("Mod√ºl Hatasƒ±", 
                        "Bu mod√ºl baƒüƒ±msƒ±z olarak √ßalƒ±≈ütƒ±rƒ±lamaz!\n\nL√ºtfen DamiseAuthGUI.py dosyasƒ±nƒ± √ßalƒ±≈ütƒ±rƒ±n ve admin giri≈üi yaparak MongoDB panelini a√ßƒ±n.")
    sys.exit(1)